---
###############################################
# PLAY 1 — Provision VM on Proxmox (cloud-init)
###############################################
- name: Provision VM on Proxmox and deploy app
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    proxmox_api_host: 10.13.104.216
    proxmox_api_user: root@pam
    proxmox_api_password: int53106
    proxmox_node: int531-06

    vm_template: "ubuntu-2404-cloudinit"
    vm_name: "bjg-demo-vm"
    vm_hostname: "bjg-demo-vm"

    vm_ip: 10.13.104.150
    vm_cidr: 24
    vm_gw: 10.13.104.254

    cloudinit_user: dev
    ansible_ssh_key_path: "/Users/niraphan/.ssh/ansible_key"

    app_dir: /opt/myapp
    app_repo: "https://github.com/9INEJAMES/int531-demo-project.git"

  tasks:
    - name: Read SSH public key (from macOS)
      ansible.builtin.set_fact:
        ssh_pubkey: "{{ lookup('file', ansible_ssh_key_path + '.pub') }}"

    - name: Create VM from cloud-init template (clone + inject ssh key + set IP/GW)
      community.proxmox.proxmox_kvm:
        api_user: "{{ proxmox_api_user }}"
        api_password: "{{ proxmox_api_password }}"
        api_host: "{{ proxmox_api_host }}"
        node: "{{ proxmox_node }}"
        clone: "{{ vm_template }}"
        name: "{{ vm_name }}"
        full: true
        timeout: 300
        ciuser: "{{ cloudinit_user }}"
        sshkeys: "{{ ssh_pubkey }}"
        ipconfig:
          ipconfig0: "ip={{ vm_ip }}/{{ vm_cidr }},gw={{ vm_gw }}"
      register: created_vm

    - name: Start new VM
      community.proxmox.proxmox_kvm:
        api_user: "{{ proxmox_api_user }}"
        api_password: "{{ proxmox_api_password }}"
        api_host: "{{ proxmox_api_host }}"
        node: "{{ proxmox_node }}"
        vmid: "{{ created_vm.vmid }}"
        state: started

    - name: Wait for SSH port open on VM
      ansible.builtin.wait_for:
        host: "{{ vm_ip }}"
        port: 22
        delay: 10
        timeout: 300

    - name: Wait until SSH login works
      ansible.builtin.command: >
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
        -i {{ ansible_ssh_key_path }}
        {{ cloudinit_user }}@{{ vm_ip }} "echo ready"
      register: ssh_ready
      retries: 20
      delay: 6
      until: ssh_ready.rc == 0
      changed_when: false

    - name: Register new VM as dynamic host
      ansible.builtin.add_host:
        name: new_vm
        ansible_host: "{{ vm_ip }}"
        ansible_user: "{{ cloudinit_user }}"
        ansible_ssh_private_key_file: "{{ ansible_ssh_key_path }}"
        ansible_python_interpreter: /usr/bin/python3
        ansible_ssh_common_args: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
        groups: provisioned

    - name: Show created VMID
      ansible.builtin.debug:
        msg: "Created VM with VMID {{ created_vm.vmid }} on {{ proxmox_node }}"

###########################################################
# PLAY 2 — Install Docker + Deploy app via docker compose
###########################################################
- name: Configure new VM and deploy app
  hosts: new_vm
  become: yes
  gather_facts: yes

  vars:
    app_dir: /opt/myapp
    app_repo: "https://github.com/9INEJAMES/int531-demo-project.git"

    # Optional: Docker Hub credentials to avoid rate limit
    # Uncomment and fill in your credentials:
    # docker_hub_username: "your_username"
    # docker_hub_password: "your_password"

    ufw_allow_ports:
      - "22"
      - "80"
      - "8000"
      - "8001"
      - "8443"

  tasks:
    ########################################
    # 0) Wait for cloud-init + apt lock
    ########################################
    - name: Wait for cloud-init to complete
      ansible.builtin.command: cloud-init status --wait
      changed_when: false
      failed_when: false

    - name: Wait for apt lock to be released
      ansible.builtin.shell: |
        while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 ; do
          echo "Waiting for apt lock..."
          sleep 5
        done
      args:
        executable: /bin/bash
      changed_when: false

    ########################################
    # 1) Base packages + Firewall
    ########################################
    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: yes
        cache_valid_time: 600

    - name: Install base tools (git, curl, gnupg, ca-certificates, ufw)
      ansible.builtin.apt:
        name:
          - git
          - ca-certificates
          - curl
          - gnupg
          - ufw
        state: present

    - name: UFW - set default incoming policy to ALLOW (⚠️ allow all)
      community.general.ufw:
        direction: incoming
        policy: allow

    - name: UFW - set default outgoing policy to ALLOW
      community.general.ufw:
        direction: outgoing
        policy: allow

    - name: UFW - allow required ports
      community.general.ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop: "{{ ufw_allow_ports }}"

    - name: UFW - enable
      community.general.ufw:
        state: enabled

    ########################################
    # 2) Time sync (TLS needs correct time)
    ########################################
    - name: Ensure time sync (NTP) is enabled
      ansible.builtin.shell: |
        set -e
        timedatectl set-ntp true || true
        systemctl restart systemd-timesyncd || true
        timedatectl status
      args:
        executable: /bin/bash
      changed_when: false

    ########################################
    # 3) Docker install
    ########################################
    - name: Ensure keyrings directory exists for Docker
      ansible.builtin.file:
        path: /etc/apt/keyrings
        state: directory
        mode: "0755"

    - name: Add Docker GPG key
      ansible.builtin.shell: |
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        chmod a+r /etc/apt/keyrings/docker.gpg
      args:
        executable: /bin/bash
        creates: /etc/apt/keyrings/docker.gpg

    - name: Get system architecture for Docker repo
      ansible.builtin.command: dpkg --print-architecture
      register: system_arch
      changed_when: false

    - name: Add Docker APT repository
      ansible.builtin.apt_repository:
        repo: "deb [arch={{ system_arch.stdout }} signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu {{ ansible_lsb.codename }} stable"
        state: present
        filename: docker
        update_cache: yes

    - name: Install Docker engine and compose plugin
      ansible.builtin.apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present

    - name: Ensure Docker daemon is enabled and running
      ansible.builtin.service:
        name: docker
        state: started
        enabled: yes

    - name: Add dev user to docker group
      ansible.builtin.user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes

    ########################################
    # 4) Docker daemon tuning + FORCE RESTART NOW
    ########################################
    - name: Configure Docker daemon DNS + concurrency
      ansible.builtin.copy:
        dest: /etc/docker/daemon.json
        mode: "0644"
        content: |
          {
            "dns": ["1.1.1.1", "8.8.8.8"],
            "max-concurrent-downloads": 3,
            "max-concurrent-uploads": 3
          }
      register: docker_config_changed

    - name: Restart Docker NOW (before app deployment)
      ansible.builtin.service:
        name: docker
        state: restarted
      when: docker_config_changed.changed

    - name: Wait for Docker to be ready after restart
      ansible.builtin.command: docker info
      register: docker_info
      retries: 10
      delay: 3
      until: docker_info.rc == 0
      changed_when: false
      when: docker_config_changed.changed

    ########################################
    # 5) Clone repo
    ########################################
    - name: Ensure app directory exists
      ansible.builtin.file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0755"

    - name: Clone app repo
      ansible.builtin.git:
        repo: "{{ app_repo }}"
        dest: "{{ app_dir }}"
        update: yes
        force: yes
        version: HEAD
      become: yes
      become_user: "{{ ansible_user }}"

    - name: Stop stack and remove volumes (fresh DB init)
      ansible.builtin.shell: |
        set -e
        cd {{ app_dir }}
        sg docker -c "docker compose down -v" || true
      args:
        executable: /bin/bash
      become: yes
      become_user: "{{ ansible_user }}"
      changed_when: false

    - name: Find init SQL file in repo (db create script)
      ansible.builtin.find:
        paths: "{{ app_dir }}"
        patterns: "001-create-role-and-db.sql"
        file_type: file
        recurse: yes
      register: init_sql_found

    - name: Set init SQL path
      ansible.builtin.set_fact:
        init_sql_path: "{{ init_sql_found.files[0].path }}"
      when: (init_sql_found.matched | int) > 0

    - name: Fail if init SQL not found
      ansible.builtin.fail:
        msg: "Cannot find 001-create-role-and-db.sql under {{ app_dir }}"
      when: (init_sql_found.matched | int) == 0

    - name: Ensure init SQL uses Postgres-compatible syntax (hotfix)
      ansible.builtin.replace:
        path: "{{ init_sql_path }}"
        regexp: 'CREATE DATABASE IF NOT EXISTS\s+([a-zA-Z0-9_]+)\s+OWNER\s+([a-zA-Z0-9_]+);'
        replace: |
          DO $$ BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_database WHERE datname = '\1') THEN
              CREATE DATABASE \1 OWNER \2;
            END IF;
          END $$;
      when: (init_sql_found.matched | int) > 0

    - name: Show which SQL file was patched
      ansible.builtin.debug:
        msg: "Patched init SQL at {{ init_sql_path }}"

    ########################################
    # 6) Docker Hub login (optional, to avoid rate limit)
    ########################################
    - name: Docker Hub login to avoid rate limit
      ansible.builtin.shell: |
        set -e
        echo "{{ docker_hub_password }}" | docker login -u "{{ docker_hub_username }}" --password-stdin
      args:
        executable: /bin/bash
      become: yes
      become_user: "{{ ansible_user }}"
      no_log: true
      when: docker_hub_username is defined and docker_hub_password is defined
      changed_when: false

    ########################################
    # 7) Compose up (capture log) + fail with diagnostics
    ########################################
    - name: Docker compose up (build + detached) from repo (capture log + higher timeouts)
      ansible.builtin.shell: |
        set -euo pipefail
        cd {{ app_dir }}
        export DOCKER_CLIENT_TIMEOUT=300
        export COMPOSE_HTTP_TIMEOUT=300
        sg docker -c "docker compose up -d --build" 2>&1 | tee /tmp/compose-up.log
      args:
        executable: /bin/bash
      become: yes
      become_user: "{{ ansible_user }}"
      register: compose_up
      failed_when: false

    - name: Show compose stdout (first 80 lines)
      ansible.builtin.debug:
        msg: "{{ (compose_up.stdout_lines | default([]))[:80] }}"

    - name: If compose failed - tail compose log
      ansible.builtin.shell: |
        tail -n 200 /tmp/compose-up.log || true
      args:
        executable: /bin/bash
      become: yes
      when: compose_up.rc != 0
      register: compose_log_tail
      changed_when: false

    - name: If compose failed - docker compose ps
      ansible.builtin.shell: |
        set -e
        cd {{ app_dir }}
        sg docker -c "docker compose ps" || true
      args:
        executable: /bin/bash
      become: yes
      become_user: "{{ ansible_user }}"
      when: compose_up.rc != 0
      register: compose_ps_on_fail
      changed_when: false

    - name: If compose failed - docker compose logs (tail 200)
      ansible.builtin.shell: |
        set -e
        cd {{ app_dir }}
        sg docker -c "docker compose logs --tail=200" || true
      args:
        executable: /bin/bash
      become: yes
      become_user: "{{ ansible_user }}"
      when: compose_up.rc != 0
      register: compose_logs_on_fail
      changed_when: false

    - name: Fail with diagnostics if compose failed
      ansible.builtin.fail:
        msg: |
          docker compose up failed (rc={{ compose_up.rc }})

          --- /tmp/compose-up.log (tail 200) ---
          {{ compose_log_tail.stdout | default('') }}

          --- docker compose ps ---
          {{ compose_ps_on_fail.stdout | default('') }}

          --- docker compose logs --tail=200 ---
          {{ compose_logs_on_fail.stdout | default('') }}
      when: compose_up.rc != 0

    ########################################
    # 8) Verify
    ########################################
    - name: Wait until containers are running
      ansible.builtin.shell: |
        set -e
        cd {{ app_dir }}
        sg docker -c "docker compose ps --status running --format json" | wc -l
      args:
        executable: /bin/bash
      become: yes
      become_user: "{{ ansible_user }}"
      register: compose_ps
      retries: 20
      delay: 6
      until: (compose_ps.stdout | int) >= 4
      changed_when: false

    - name: Quick HTTP checks (inside VM)
      ansible.builtin.shell: |
        set -e
        curl -fsS http://127.0.0.1/ >/dev/null
        curl -fsS http://127.0.0.1:8000/ >/dev/null
      args:
        executable: /bin/bash
      become: yes
      changed_when: false

    - name: Show deployment summary
      ansible.builtin.debug:
        msg: |
          ✅ Deployment completed successfully!
          
          Services running on {{ vm_ip }}:
          - Frontend: http://{{ vm_ip }}
          - Backend: http://{{ vm_ip }}:8000
          
          SSH access: ssh -i {{ ansible_ssh_key_path }} {{ cloudinit_user }}@{{ vm_ip }}